// File generated by the BNF Converter (bnfc 2.9.4.1).

package stella;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class VisitSkel
{
  public class ProgramVisitor<R,A> implements stella.Absyn.Program.Visitor<R,A>
  {
    public R visit(stella.Absyn.AProgram p, A arg)
    { /* Code for AProgram goes here */
      p.languagedecl_.accept(new LanguageDeclVisitor<R,A>(), arg);
      for (stella.Absyn.Extension x: p.listextension_) {
        x.accept(new ExtensionVisitor<R,A>(), arg);
      }
      for (stella.Absyn.Decl x: p.listdecl_) {
        x.accept(new DeclVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class LanguageDeclVisitor<R,A> implements stella.Absyn.LanguageDecl.Visitor<R,A>
  {
    public R visit(stella.Absyn.LanguageCore p, A arg)
    { /* Code for LanguageCore goes here */
      return null;
    }
  }
  public class ExtensionVisitor<R,A> implements stella.Absyn.Extension.Visitor<R,A>
  {
    public R visit(stella.Absyn.AnExtension p, A arg)
    { /* Code for AnExtension goes here */
      for (String x: p.listextensionname_) {
        //x;
      }
      return null;
    }
  }
  public class DeclVisitor<R,A> implements stella.Absyn.Decl.Visitor<R,A>
  {
    public R visit(stella.Absyn.DeclFun p, A arg)
    { /* Code for DeclFun goes here */
      for (stella.Absyn.Annotation x: p.listannotation_) {
        x.accept(new AnnotationVisitor<R,A>(), arg);
      }
      //p.stellaident_;
      for (stella.Absyn.ParamDecl x: p.listparamdecl_) {
        x.accept(new ParamDeclVisitor<R,A>(), arg);
      }
      p.returntype_.accept(new ReturnTypeVisitor<R,A>(), arg);
      p.throwtype_.accept(new ThrowTypeVisitor<R,A>(), arg);
      for (stella.Absyn.Decl x: p.listdecl_) {
        x.accept(new DeclVisitor<R,A>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.DeclTypeAlias p, A arg)
    { /* Code for DeclTypeAlias goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class LocalDeclVisitor<R,A> implements stella.Absyn.LocalDecl.Visitor<R,A>
  {
    public R visit(stella.Absyn.ALocalDecl p, A arg)
    { /* Code for ALocalDecl goes here */
      p.decl_.accept(new DeclVisitor<R,A>(), arg);
      return null;
    }
  }
  public class AnnotationVisitor<R,A> implements stella.Absyn.Annotation.Visitor<R,A>
  {
    public R visit(stella.Absyn.InlineAnnotation p, A arg)
    { /* Code for InlineAnnotation goes here */
      return null;
    }
  }
  public class ParamDeclVisitor<R,A> implements stella.Absyn.ParamDecl.Visitor<R,A>
  {
    public R visit(stella.Absyn.AParamDecl p, A arg)
    { /* Code for AParamDecl goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ReturnTypeVisitor<R,A> implements stella.Absyn.ReturnType.Visitor<R,A>
  {
    public R visit(stella.Absyn.NoReturnType p, A arg)
    { /* Code for NoReturnType goes here */
      return null;
    }
    public R visit(stella.Absyn.SomeReturnType p, A arg)
    { /* Code for SomeReturnType goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ThrowTypeVisitor<R,A> implements stella.Absyn.ThrowType.Visitor<R,A>
  {
    public R visit(stella.Absyn.NoThrowType p, A arg)
    { /* Code for NoThrowType goes here */
      return null;
    }
    public R visit(stella.Absyn.SomeThrowType p, A arg)
    { /* Code for SomeThrowType goes here */
      for (stella.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class ExprVisitor<R,A> implements stella.Absyn.Expr.Visitor<R,A>
  {
    public R visit(stella.Absyn.If p, A arg)
    { /* Code for If goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      p.expr_3.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Let p, A arg)
    { /* Code for Let goes here */
      //p.stellaident_;
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.LessThan p, A arg)
    { /* Code for LessThan goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.LessThanOrEqual p, A arg)
    { /* Code for LessThanOrEqual goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.GreaterThan p, A arg)
    { /* Code for GreaterThan goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.GreaterThanOrEqual p, A arg)
    { /* Code for GreaterThanOrEqual goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Equal p, A arg)
    { /* Code for Equal goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.NotEqual p, A arg)
    { /* Code for NotEqual goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.TypeAsc p, A arg)
    { /* Code for TypeAsc goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Abstraction p, A arg)
    { /* Code for Abstraction goes here */
      for (stella.Absyn.ParamDecl x: p.listparamdecl_) {
        x.accept(new ParamDeclVisitor<R,A>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Tuple p, A arg)
    { /* Code for Tuple goes here */
      for (stella.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.Record p, A arg)
    { /* Code for Record goes here */
      for (stella.Absyn.Binding x: p.listbinding_) {
        x.accept(new BindingVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.Variant p, A arg)
    { /* Code for Variant goes here */
      //p.stellaident_;
      p.exprdata_.accept(new ExprDataVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Match p, A arg)
    { /* Code for Match goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      for (stella.Absyn.MatchCase x: p.listmatchcase_) {
        x.accept(new MatchCaseVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.List p, A arg)
    { /* Code for List goes here */
      for (stella.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.Add p, A arg)
    { /* Code for Add goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.LogicOr p, A arg)
    { /* Code for LogicOr goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Multiply p, A arg)
    { /* Code for Multiply goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.LogicAnd p, A arg)
    { /* Code for LogicAnd goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Application p, A arg)
    { /* Code for Application goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      for (stella.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.ConsList p, A arg)
    { /* Code for ConsList goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Head p, A arg)
    { /* Code for Head goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.IsEmpty p, A arg)
    { /* Code for IsEmpty goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Tail p, A arg)
    { /* Code for Tail goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Succ p, A arg)
    { /* Code for Succ goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.LogicNot p, A arg)
    { /* Code for LogicNot goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Pred p, A arg)
    { /* Code for Pred goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.IsZero p, A arg)
    { /* Code for IsZero goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Fix p, A arg)
    { /* Code for Fix goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.NatRec p, A arg)
    { /* Code for NatRec goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      p.expr_3.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Fold p, A arg)
    { /* Code for Fold goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.Unfold p, A arg)
    { /* Code for Unfold goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.DotRecord p, A arg)
    { /* Code for DotRecord goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      //p.stellaident_;
      return null;
    }
    public R visit(stella.Absyn.DotTuple p, A arg)
    { /* Code for DotTuple goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      //p.integer_;
      return null;
    }
    public R visit(stella.Absyn.ConstTrue p, A arg)
    { /* Code for ConstTrue goes here */
      return null;
    }
    public R visit(stella.Absyn.ConstFalse p, A arg)
    { /* Code for ConstFalse goes here */
      return null;
    }
    public R visit(stella.Absyn.ConstInt p, A arg)
    { /* Code for ConstInt goes here */
      //p.integer_;
      return null;
    }
    public R visit(stella.Absyn.Var p, A arg)
    { /* Code for Var goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class MatchCaseVisitor<R,A> implements stella.Absyn.MatchCase.Visitor<R,A>
  {
    public R visit(stella.Absyn.AMatchCase p, A arg)
    { /* Code for AMatchCase goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
  }
  public class OptionalTypingVisitor<R,A> implements stella.Absyn.OptionalTyping.Visitor<R,A>
  {
    public R visit(stella.Absyn.NoTyping p, A arg)
    { /* Code for NoTyping goes here */
      return null;
    }
    public R visit(stella.Absyn.SomeTyping p, A arg)
    { /* Code for SomeTyping goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class PatternDataVisitor<R,A> implements stella.Absyn.PatternData.Visitor<R,A>
  {
    public R visit(stella.Absyn.NoPatternData p, A arg)
    { /* Code for NoPatternData goes here */
      return null;
    }
    public R visit(stella.Absyn.SomePatternData p, A arg)
    { /* Code for SomePatternData goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ExprDataVisitor<R,A> implements stella.Absyn.ExprData.Visitor<R,A>
  {
    public R visit(stella.Absyn.NoExprData p, A arg)
    { /* Code for NoExprData goes here */
      return null;
    }
    public R visit(stella.Absyn.SomeExprData p, A arg)
    { /* Code for SomeExprData goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
  }
  public class PatternVisitor<R,A> implements stella.Absyn.Pattern.Visitor<R,A>
  {
    public R visit(stella.Absyn.PatternVariant p, A arg)
    { /* Code for PatternVariant goes here */
      //p.stellaident_;
      p.patterndata_.accept(new PatternDataVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.PatternTuple p, A arg)
    { /* Code for PatternTuple goes here */
      for (stella.Absyn.Pattern x: p.listpattern_) {
        x.accept(new PatternVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.PatternRecord p, A arg)
    { /* Code for PatternRecord goes here */
      for (stella.Absyn.LabelledPattern x: p.listlabelledpattern_) {
        x.accept(new LabelledPatternVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.PatternList p, A arg)
    { /* Code for PatternList goes here */
      for (stella.Absyn.Pattern x: p.listpattern_) {
        x.accept(new PatternVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.PatternCons p, A arg)
    { /* Code for PatternCons goes here */
      p.pattern_1.accept(new PatternVisitor<R,A>(), arg);
      p.pattern_2.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.PatternFalse p, A arg)
    { /* Code for PatternFalse goes here */
      return null;
    }
    public R visit(stella.Absyn.PatternTrue p, A arg)
    { /* Code for PatternTrue goes here */
      return null;
    }
    public R visit(stella.Absyn.PatternInt p, A arg)
    { /* Code for PatternInt goes here */
      //p.integer_;
      return null;
    }
    public R visit(stella.Absyn.PatternSucc p, A arg)
    { /* Code for PatternSucc goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.PatternVar p, A arg)
    { /* Code for PatternVar goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class LabelledPatternVisitor<R,A> implements stella.Absyn.LabelledPattern.Visitor<R,A>
  {
    public R visit(stella.Absyn.ALabelledPattern p, A arg)
    { /* Code for ALabelledPattern goes here */
      //p.stellaident_;
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
  }
  public class BindingVisitor<R,A> implements stella.Absyn.Binding.Visitor<R,A>
  {
    public R visit(stella.Absyn.ABinding p, A arg)
    { /* Code for ABinding goes here */
      //p.stellaident_;
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
  }
  public class TypeVisitor<R,A> implements stella.Absyn.Type.Visitor<R,A>
  {
    public R visit(stella.Absyn.TypeFun p, A arg)
    { /* Code for TypeFun goes here */
      for (stella.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,A>(), arg);
      }
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.TypeRec p, A arg)
    { /* Code for TypeRec goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.TypeSum p, A arg)
    { /* Code for TypeSum goes here */
      p.type_1.accept(new TypeVisitor<R,A>(), arg);
      p.type_2.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.TypeTuple p, A arg)
    { /* Code for TypeTuple goes here */
      for (stella.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.TypeRecord p, A arg)
    { /* Code for TypeRecord goes here */
      for (stella.Absyn.RecordFieldType x: p.listrecordfieldtype_) {
        x.accept(new RecordFieldTypeVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.TypeVariant p, A arg)
    { /* Code for TypeVariant goes here */
      for (stella.Absyn.VariantFieldType x: p.listvariantfieldtype_) {
        x.accept(new VariantFieldTypeVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(stella.Absyn.TypeList p, A arg)
    { /* Code for TypeList goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(stella.Absyn.TypeBool p, A arg)
    { /* Code for TypeBool goes here */
      return null;
    }
    public R visit(stella.Absyn.TypeNat p, A arg)
    { /* Code for TypeNat goes here */
      return null;
    }
    public R visit(stella.Absyn.TypeUnit p, A arg)
    { /* Code for TypeUnit goes here */
      return null;
    }
    public R visit(stella.Absyn.TypeVar p, A arg)
    { /* Code for TypeVar goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class VariantFieldTypeVisitor<R,A> implements stella.Absyn.VariantFieldType.Visitor<R,A>
  {
    public R visit(stella.Absyn.AVariantFieldType p, A arg)
    { /* Code for AVariantFieldType goes here */
      //p.stellaident_;
      p.optionaltyping_.accept(new OptionalTypingVisitor<R,A>(), arg);
      return null;
    }
  }
  public class RecordFieldTypeVisitor<R,A> implements stella.Absyn.RecordFieldType.Visitor<R,A>
  {
    public R visit(stella.Absyn.ARecordFieldType p, A arg)
    { /* Code for ARecordFieldType goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class TypingVisitor<R,A> implements stella.Absyn.Typing.Visitor<R,A>
  {
    public R visit(stella.Absyn.ATyping p, A arg)
    { /* Code for ATyping goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
}
